//_____________________________/\_______________________________
//==============================================================
//                      SETUP FOR RVM
//--------------------------------------------------------------
// Example of integrating
// What to do before including header (below)
//==============================================================
// Modes {0:=BVM/PVM 240p-like,1:=Wega TV 480p-like,2:=arcade}
#define RVM_MODE 2
// Select portability paths
#define RVM_GLSL 1
// #define RVM_HLSL 1
// Select 32-bit or packed 16-bit source path
#define RVM_32BIT 1
// Debug pixels
// TODO: Actually RVM_ZOOM is currently broken (sorry)
//#define RVM_ZOOM 1
// Toggle on/off warping of screen
#define RVM_WARP 1
// Debug split line position (comment out to remove)
#define RVM_SPLIT 200
//_____________________________/\_______________________________
//==============================================================
//                SPECIFIC TO SHADERTOY EXAMPLE
//==============================================================
// Horizonal scan blur
//  0.50 := blurry
//  0.75 := default
//  1.00 := blocky
#define INPUT_BLUR 0.75
//--------------------------------------------------------------
// Since shadertoy doesn't have sRGB textures
// And we need linear input into shader
// Don't do this in your code
float FromSrgb1(float c){
 return (c<=0.04045)?c*(1.0/12.92):
  pow(c*(1.0/1.055)+(0.055/1.055),2.4);}
//--------------------------------------------------------------
vec3 FromSrgb(vec3 c){return vec3(
 FromSrgb1(c.r),FromSrgb1(c.g),FromSrgb1(c.b));}
//--------------------------------------------------------------
// Output pixels per input pixel (can be fractional)
// Enables consistent output regardless of viewport size
#if RVM_MODE==0
 #define INPUT_DOT 4.8
#else
 #define INPUT_DOT 2.8
#endif
//--------------------------------------------------------------
// Setup the function which returns gather4 results
// Have to emulate gather4 as ShaderToy doesn't support it
// Gather 4 ordering
//  W Z
//  X Y
vec4 RvmR4F(vec2 uv){
 // For shadertoy, scale to get native texels in the image
 uv*=iResolution.xy/vec2(INPUT_DOT,INPUT_DOT);
 vec2 px=vec2(1.0,1.0)/iChannelResolution[0].xy;
 uv*=px;
 px*=0.5;
 vec4 o;
 o.w=FromSrgb1(textureLod(iChannel0,uv.xy+vec2(-px.x,-px.y),0.0).r);
 o.z=FromSrgb1(textureLod(iChannel0,uv.xy+vec2( px.x,-px.y),0.0).r);
 o.x=FromSrgb1(textureLod(iChannel0,uv.xy+vec2(-px.x, px.y),0.0).r);
 o.y=FromSrgb1(textureLod(iChannel0,uv.xy+vec2( px.x, px.y),0.0).r);
 return o;}
//
vec4 RvmG4F(vec2 uv){
 // For shadertoy, scale to get native texels in the image
 uv*=iResolution.xy/vec2(INPUT_DOT,INPUT_DOT);
 vec2 px=vec2(1.0,1.0)/iChannelResolution[0].xy;
 uv*=px;
 px*=0.5;
 vec4 o;
 o.w=FromSrgb1(textureLod(iChannel0,uv.xy+vec2(-px.x,-px.y),0.0).g);
 o.z=FromSrgb1(textureLod(iChannel0,uv.xy+vec2( px.x,-px.y),0.0).g);
 o.x=FromSrgb1(textureLod(iChannel0,uv.xy+vec2(-px.x, px.y),0.0).g);
 o.y=FromSrgb1(textureLod(iChannel0,uv.xy+vec2( px.x, px.y),0.0).g);
 return o;}
//
vec4 RvmB4F(vec2 uv){
 // For shadertoy, scale to get native texels in the image
 uv*=iResolution.xy/vec2(INPUT_DOT,INPUT_DOT);
 vec2 px=vec2(1.0,1.0)/iChannelResolution[0].xy;
 uv*=px;
 px*=0.5;
 vec4 o;
 o.w=FromSrgb1(textureLod(iChannel0,uv.xy+vec2(-px.x,-px.y),0.0).b);
 o.z=FromSrgb1(textureLod(iChannel0,uv.xy+vec2( px.x,-px.y),0.0).b);
 o.x=FromSrgb1(textureLod(iChannel0,uv.xy+vec2(-px.x, px.y),0.0).b);
 o.y=FromSrgb1(textureLod(iChannel0,uv.xy+vec2( px.x, px.y),0.0).b);
 return o;}
 
 



//_______________________BEGIN_HEADER___________________________
//_______________________BEGIN_HEADER___________________________
//_______________________BEGIN_HEADER___________________________
//_______________________BEGIN_HEADER___________________________
//_______________________BEGIN_HEADER___________________________
//_______________________BEGIN_HEADER___________________________
//_______________________BEGIN_HEADER___________________________
//_______________________BEGIN_HEADER___________________________








////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//_____________________________.._______________________________
//==============================================================
//
//
//             [RVM] RETRO VIDEO MONITOR - v20210519
//                         _
//                     by  |imothy Lottes
//
//
//==============================================================
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//_____________________________.._______________________________
//==============================================================
//
//                           ABOUT
//
//--------------------------------------------------------------
// RVM is a CRT stylized up-sampler with three modes
// RVM requires linear color inputs {0.0 to 1.0} ranged
// Non-integer scaling works best
// Using RVM_WARP also improves output
//--------------------------------------------------------------
// RVM_MODE 0
// ==========
// Designed for '240p' and similar input resolutions
// Meaning 4x or more scaling on a dimension
// So a 1080p output needs to have <= 270 pix height input
// Inspired by Sony PVM and BVM display output
// No grille, instead focusing on scanlines
// Scanline thickness is variable to simulate phosphor bloom
// Scanline thickness is highest at color peak
// Output intensity increases to normalize out scan thining
// Thus there is only a slight reduction in peak brightness
//--------------------------------------------------------------
// RVM_MODE 1
// ==========
// Designed for '480p' and similar input resolutions
// No visible scanlines, instead this focuses on grille
// Inspired by Sony Wega TV display output
// Filters mostly vertical since grille masks the horizontal
// Using similar normalization tick to maintain peak brightness 
//--------------------------------------------------------------
// RVM_MODE 2
// ==========
// Same as mode 1 except this has a slot mask instead of grille
// Inspired by vintage arcade CRTs
//--------------------------------------------------------------
// TODO
// ====
// - This is an initial prototype
// - Currently only tested for RVM_32BIT and RVM_GLSL
// - HLSL and 16BIT paths might have bugs
// - Put in approximations
//==============================================================
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//_____________________________.._______________________________
//==============================================================
//
//          LICENSE = UNLICENSE (aka PUBLIC DOMAIN)
//
//--------------------------------------------------------------
// This is free and unencumbered software released into the 
// public domain.
//--------------------------------------------------------------
// Anyone is free to copy, modify, publish, use, compile, sell, 
// or distribute this software, either in source code form or as
// a compiled binary, for any purpose, commercial or 
// non-commercial, and by any means.
//--------------------------------------------------------------
// In jurisdictions that recognize copyright laws, the author or
// authors of this software dedicate any and all copyright 
// interest in the software to the public domain. We make this
// dedication for the benefit of the public at large and to the
// detriment of our heirs and successors. We intend this 
// dedication to be an overt act of relinquishment in perpetuity
// of all present and future rights to this software under 
// copyright law.
//--------------------------------------------------------------
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
// KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE 
// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
// PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
// AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT 
// OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
// DEALINGS IN THE SOFTWARE.
//--------------------------------------------------------------
// For more information, please refer to 
// <http://unlicense.org/>
//==============================================================
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//_____________________________.._______________________________
//==============================================================
//                         PORTABILITY
//==============================================================
#define RVM_2PI 6.28318530718
//--------------------------------------------------------------
#ifdef RVM_GLSL
 #define RvmF1 float
 #define RvmF2 vec2
 #define RvmF2_(x) vec2((x),(x))
 #define RvmF3 vec3
 #define RvmF3_(x) vec3((x),(x),(x))
 #define RvmF4 vec4
 #define RvmU1 uint
 #define RvmFractF1 fract
 // As close to the V_COS_F32 as possible without intrinsic
 #define RvmNCosF2(x) cos((x)*RvmF2_(RVM_2PI))
 #define RvmRcpF1(x) (1.0/(x))
 #define RvmRcpF2(x) (RvmF2_(1.0)/(x))
 #define RvmRcpF3(x) (RvmF3_(1.0)/(x))
 #define RvmSatF1(x) clamp((x),0.0,1.0)
 #define RvmSatF2(x) clamp((x),0.0,1.0)
//--------------------------------------------------------------
 RvmF1 RvmMax3F1(RvmF1 a,RvmF1 b,RvmF1 c){
  return max(a,max(b,c));}
//--------------------------------------------------------------
 RvmF2 RvmMax3F2(RvmF2 a,RvmF2 b,RvmF2 c){
  return max(a,max(b,c));}
//--------------------------------------------------------------
 #ifdef RVM_16BIT
  #define RvmH1 float16_t
  #define RvmH2 f16vec2
  #define RvmH2_(x) f16vec2((x),(x))
  #define RvmH3 f16vec3
  #define RvmH3_(x) f16vec3((x),(x),(x))
  #define RvmH4 f16vec4
  #define RvmFractH1 fract
  #define RvmNCosH2(x) cos((x)*RvmH2_(RVM_2PI))
  #define RvmRcpH1(x) (RvmH1(1.0)/(x))
  #define RvmRcpH2(x) (RvmH2_(1.0)/(x))
  #define RvmRcpH3(x) (RvmH3_(1.0)/(x))
  #define RvmSatH1(x) clamp((x),RvmH1(0.0),RvmH1(1.0))
  #define RvmSatH2(x) clamp((x),RvmH2(0.0,0.0),RvmH2(1.0,1.0))
//--------------------------------------------------------------
  RvmH1 RvmMax3H1(RvmH1 a,RvmH1 b,RvmH1 c){
   return max(a,max(b,c));}
//--------------------------------------------------------------
  RvmH2 RvmMax3H2(RvmH2 a,RvmH2 b,RvmH2 c){
   return max(a,max(b,c));}
//--------------------------------------------------------------
 #endif
#endif
//==============================================================
#ifdef RVM_HLSL
 #define RvmF1 float
 #define RvmF2 float2
 #define RvmF2_(x) float2((x),(x))
 #define RvmF3 float3
 #define RvmF3_(x) float3((x),(x),(x))
 #define RvmF4 float4
 #define RvmU1 uint
 // Better match to the GCN opcode V_FRACT_F32
 RvmF1 RvmFractF1(RvmF1 x){return x-floor(x);}
 #define RvmNCosF2(x) cos((x)*RvmF2_(RVM_2PI))
 #define RvmRcpF1(x) rcp(x)
 #define RvmRcpF2(x) rcp(x)
 #define RvmRcpF3(x) rcp(x)
 #define RvmSatF1(x) saturate(x)
 #define RvmSatF2(x) saturate(x)
//--------------------------------------------------------------
 RvmF1 RvmMax3F1(RvmF1 a,RvmF1 b,RvmF1 c){
  return max(a,max(b,c));}
//--------------------------------------------------------------
 RvmF2 RvmMax3F2(RvmF2 a,RvmF2 b,RvmF2 c){
  return max(a,max(b,c));}
//--------------------------------------------------------------
 #ifdef RVM_16BIT
  #define RvmH1 min16float
  #define RvmH2 min16float2
  #define RvmH2_(x) min16float2((x),(x))
  #define RvmH3 min16float3
  #define RvmH3_(x) min16float3((x),(x),(x))
  #define RvmH4 min16float4
  RvmH1 RvmFractH1(RvmH1 x){return x-floor(x);}
  #define RvmNCosH2(x) cos((x)*RvmH2_(RVM_2PI))
  #define RvmRcpH1(x) rcp(x)
  #define RvmRcpH2(x) rcp(x)
  #define RvmRcpH3(x) rcp(x)
  #define RvmSatH1(x) saturate(x)
  #define RvmSatH2(x) saturate(x)
//--------------------------------------------------------------
  RvmH1 RvmMax3H1(RvmH1 a,RvmH1 b,RvmH1 c){
   return max(a,max(b,c));}
//--------------------------------------------------------------
  RvmH2 RvmMax3H2(RvmH2 a,RvmH2 b,RvmH2 c){
   return max(a,max(b,c));}
//--------------------------------------------------------------
 #endif
#endif
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//_____________________________.._______________________________
//==============================================================
//                        FILTER CONTROL
//==============================================================
#define RVM_DARK (7.0/8.0)
#define RVM_SCAN_DIV 3.0
#define RVM_SCAN_MAX (8.0/15.0)
#define RVM_SCAN_MIN (RVM_SCAN_DIV*RVM_SCAN_MAX)
#define RVM_SCAN_SIZ (RVM_SCAN_MAX-RVM_SCAN_MIN)
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//_____________________________.._______________________________
//==============================================================
//                     FILTER ENTRY F32
//--------------------------------------------------------------
// Input must be linear {0.0 to 1.0}
// Output color is linear
//==============================================================
#ifdef RVM_32BIT
 // Paired gaussian approximation
 RvmF2 RvmPolyF2(RvmF2 x){
  x=RvmSatF2(-x*x+RvmF2(1.0,1.0));return x*x;}
//==============================================================
 RvmF3 RvmF(
//--------------------------------------------------------------
 // SV_POSITION, fragCoord.xy, etc
 RvmF2 ipos,
//--------------------------------------------------------------
 // inputSize / outputSize (in pixels)
 RvmF2 inputSizeDivOutputSize,     
//--------------------------------------------------------------
 // 0.5 * inputSize (in pixels)
 RvmF2 halfInputSize,
//--------------------------------------------------------------
 // 1.0 / inputSize (in pixels)
 RvmF2 rcpInputSize,
//--------------------------------------------------------------
 // 2.0 / outputSize (in pixels)
 RvmF2 twoDivOutputSize,   
//--------------------------------------------------------------
 // inputSize.y
 RvmF1 inputHeight,
//--------------------------------------------------------------
 // Warp scanlines
 //  0.0 = no warp
 //  1.0/64.0 = light warping
 //  1.0/32.0 = more warping
 // Want x and y warping to be different (based on aspect)
 RvmF2 warp,
//--------------------------------------------------------------
 // Control horizontal blur
 //  0.50 := blurry
 //  0.75 := default
 //  1.00 := blocky
 RvmF1 blur,
 // Derived constant {0.5*blur,-0.5*blur,-1.5*blur,-2.5*blur}
 RvmF4 blur4){
//--------------------------------------------------------------
  #ifdef RVM_ZOOM
   ipos=floor(ipos*RvmF2(0.5));
  #endif
//--------------------------------------------------------------
  // Optional apply warp
  RvmF2 pos;
  #ifdef RVM_WARP
   // Convert to {-1 to 1} range
   pos=ipos*twoDivOutputSize-RvmF2_(1.0);
   // Distort pushes image outside {-1 to 1} range
   pos*=RvmF2_(1.0)+pos.yx*pos.yx*warp;
   // Vignette to kill off-image content
   RvmF2 vin2=RvmSatF2(pos*pos);  
   // 1-((1-x)*(1-y)) -> (1-x)*y+x
   RvmF1 vin=(RvmF1(1.0)-vin2.x)*vin2.y+vin2.x;
   vin=RvmSatF1((-vin)*inputHeight+inputHeight);   
   // Leave in {0 to inputSize}
   pos=pos*halfInputSize+halfInputSize;     
  #else
   pos=ipos*inputSizeDivOutputSize;
  #endif
//--------------------------------------------------------------
  // Get to center for first gather 4
  //  W Z W Z
  //  X Y X Y
  #if RVM_MODE==0
   RvmF2 g=floor(pos+RvmF2(-1.5,-0.5))+RvmF2_(1.0);
   RvmF2 gp=g*rcpInputSize;
   g.y-=RvmF1(0.5);
  #endif
//--------------------------------------------------------------
  // Get to center for first gather 4
  //  W Z
  //  X Y
  //  W Z
  //  X Y
  #if RVM_MODE!=0
   RvmF2 g=floor(pos+RvmF2(-0.5,-1.5))+RvmF2_(1.0);
   RvmF2 gp=g*rcpInputSize;
   g.x-=RvmF1(0.5);
  #endif
//--------------------------------------------------------------
  // Using gather4 to keep in SoA form for packed 16-bit
  // Both 32-bit and 16-bit paths use same logic
  // Gather 4 ordering
  //  W Z
  //  X Y
  // 4x2 sampled footprint
  //  _S_ _T_
  //  W Z W Z
  //  X Y X Y
  #if RVM_MODE==0
   RvmF4 colRS=RvmR4F(gp);
   RvmF4 colGS=RvmG4F(gp);
   RvmF4 colBS=RvmB4F(gp);
   gp.x+=RvmF1(2.0*rcpInputSize.x);
   RvmF4 colRT=RvmR4F(gp);
   RvmF4 colGT=RvmG4F(gp);
   RvmF4 colBT=RvmB4F(gp);
  #endif
//--------------------------------------------------------------
  // 2x4 sampled footprint
  //  W Z |s
  //  X Y |s
  //  W Z :t
  //  X Y :t
  #if RVM_MODE!=0
   RvmF4 colRS=RvmR4F(gp);
   RvmF4 colGS=RvmG4F(gp);
   RvmF4 colBS=RvmB4F(gp);
   gp.y+=RvmF1(2.0*rcpInputSize.y);
   RvmF4 colRT=RvmR4F(gp);
   RvmF4 colGT=RvmG4F(gp);
   RvmF4 colBT=RvmB4F(gp);
  #endif
//--------------------------------------------------------------
  // Debug view without effect
  #ifdef RVM_SPLIT
   if(ipos.x<RvmF1(RVM_SPLIT)){
    return RvmF3(colRS.z,colGS.z,colBS.z);}
  #endif
//--------------------------------------------------------------
  // Horizontal kernel is simple gaussian filter approximation
  #if RVM_MODE==0
   RvmF1 offB=RvmF1(pos.x-g.x);
   RvmF2 offS=RvmF2(offB,offB)*RvmF2_(blur)+blur4.xy;
   RvmF2 offT=RvmF2(offB,offB)*RvmF2_(blur)+blur4.zw;
   RvmF2 horS=RvmPolyF2(offS);
   RvmF2 horT=RvmPolyF2(offT);
  #endif
//--------------------------------------------------------------
  // Vertical
  #if RVM_MODE!=0
   RvmF1 offB=RvmF1(pos.y-g.y);
   RvmF2 offS=RvmF2(offB,offB)*RvmF2_(blur)+blur4.xy;
   RvmF2 offT=RvmF2(offB,offB)*RvmF2_(blur)+blur4.zw;
   RvmF2 horS=RvmPolyF2(offS);
   RvmF2 horT=RvmPolyF2(offT);
  #endif
//--------------------------------------------------------------
  // Get kernel totals and then rcp
  RvmF2 hor0=horS+horT;
  RvmF1 horD=RvmRcpF1(hor0.x+hor0.y);
//--------------------------------------------------------------
  // Get rid of off-screen pixels on edge
  #ifdef RVM_WARP
   horD*=RvmF1(vin);
  #endif
//--------------------------------------------------------------
  // Apply horizontal filter, up and down sums
  #if RVM_MODE==0
   RvmF2 colRU2=colRS.wz*horS+colRT.wz*horT;
   RvmF2 colGU2=colGS.wz*horS+colGT.wz*horT;
   RvmF2 colBU2=colBS.wz*horS+colBT.wz*horT;
   RvmF2 colRD2=colRS.xy*horS+colRT.xy*horT;
   RvmF2 colGD2=colGS.xy*horS+colGT.xy*horT;
   RvmF2 colBD2=colBS.xy*horS+colBT.xy*horT;
//--------------------------------------------------------------
   // Pair total so that {x:=up, y:=down}
   // Expensive transpose from pairs of taps, to pairs of lines
   RvmF2 colRL=RvmF2(colRU2.x+colRU2.y,colRD2.x+colRD2.y);
   RvmF2 colGL=RvmF2(colGU2.x+colGU2.y,colGD2.x+colGD2.y);
   RvmF2 colBL=RvmF2(colBU2.x+colBU2.y,colBD2.x+colBD2.y);
  #endif
//--------------------------------------------------------------
  // Apply vertical filter
  #if RVM_MODE!=0
   RvmF2 colRL=colRS.wz*horS.xx+colRS.xy*horS.yy+
               colRT.wz*horT.xx+colRT.xy*horT.yy;  
   RvmF2 colGL=colGS.wz*horS.xx+colGS.xy*horS.yy+
               colGT.wz*horT.xx+colGT.xy*horT.yy;  
   RvmF2 colBL=colBS.wz*horS.xx+colBS.xy*horS.yy+
               colBT.wz*horT.xx+colBT.xy*horT.yy;  
  #endif
//--------------------------------------------------------------
  // Normalize by kernel total
  colRL*=RvmF2_(horD);
  colGL*=RvmF2_(horD);
  colBL*=RvmF2_(horD);
//--------------------------------------------------------------
  #if RVM_MODE==0
   // Get channel maximums and shape
   RvmF2 colML=RvmMax3F2(colRL,colGL,colBL);
   // TODO: Approximation...
   colML=sqrt(colML);
//--------------------------------------------------------------
   // Convert shaped channel maximums into scan width
   RvmF2 scnL=colML*RvmF2_(RVM_SCAN_SIZ)+RvmF2_(RVM_SCAN_MIN);
   RvmF1 offY=RvmF1(pos.y-g.y);
   scnL.x=( offY)*scnL.x;  
   scnL.y=(-offY)*scnL.y+scnL.y;  
   scnL=min(RvmF2_(0.5),scnL);
   scnL=RvmNCosF2(scnL);
   scnL=scnL*RvmF2_(0.5)+RvmF2_(0.5);
//--------------------------------------------------------------
   // Normalize for reduction in scan width
   RvmF2 nrmL=RvmF2_(1.0)-colML;
   nrmL=nrmL*RvmF2_(RVM_SCAN_MIN/RVM_SCAN_MAX-1.0)+RvmF2_(1.0);
   scnL*=nrmL;
  #endif
//--------------------------------------------------------------
  #if RVM_MODE!=0
   RvmF1 offX=RvmF1(pos.x-g.x);
   RvmF2 scnL=RvmF2(RvmF1(1.0)-offX,offX);
  #endif
//--------------------------------------------------------------
  // Apply scan
  colRL*=scnL; 
  colGL*=scnL;   
  colBL*=scnL;
//--------------------------------------------------------------
  // Merge contribution from both nearest lines
  RvmF3 col;
  col.r=colRL.x+colRL.y;
  col.g=colGL.x+colGL.y;
  col.b=colBL.x+colBL.y;
//--------------------------------------------------------------
  // Grille
  #if RVM_MODE==1
   RvmF1 lim=RvmF1(1.0/((1.0/3.0)+(2.0/3.0)*RVM_DARK));
   RvmF3 colD=col*col;
   colD*=RVM_DARK;
   RvmF3 amp=RvmRcpF3(
    RvmF3_(lim*1.0/3.0)+RvmF3_(lim*2.0/3.0)*col);
   ipos.x=RvmFractF1(ipos.x*RvmF1(1.0/3.0));
   col*=amp;colD*=amp;
   if(     ipos.x<RvmF1(1.0/3.0)){colD.r=col.r;}
   else if(ipos.x<RvmF1(2.0/3.0)){colD.g=col.g;}
   else                          {colD.b=col.b;}
   return colD;
  #endif
//--------------------------------------------------------------
  // Slot mask
  #if RVM_MODE==2
   RvmF1 lim=RvmF1(1.0/((3.0/12.0)+(9.0/12.0)*RVM_DARK));
   if(RvmFractF1(ipos.x*RvmF1(1.0/6.0))>RvmF1(0.5))
    ipos.y+=RvmF1(2.0);
   ipos.y=RvmFractF1(ipos.y*RvmF1(1.0/4.0));
   RvmF3 colD=col*col;
   colD*=RVM_DARK;
   RvmF3 amp=RvmRcpF3(
    RvmF3_(lim*3.0/12.0)+RvmF3_(lim*9.0/12.0)*col);
   ipos.x=RvmFractF1(ipos.x*RvmF1(1.0/3.0));
   col*=amp;colD*=amp;
   if(ipos.y>RvmF1(1.0/4.0)){
    if(     ipos.x<RvmF1(1.0/3.0)){colD.r=col.r;}
    else if(ipos.x<RvmF1(2.0/3.0)){colD.g=col.g;}
    else                          {colD.b=col.b;}}
   return colD;
  #endif
//--------------------------------------------------------------
  return col;}
#endif
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//_____________________________.._______________________________
//==============================================================
//                     FILTER ENTRY F16
//--------------------------------------------------------------
// Input must be linear {0.0 to 1.0}
// Output color is linear
//==============================================================
#ifdef RVM_16BIT
 // Paired gaussian approximation
 RvmH2 RvmPolyH2(RvmH2 x){
  x=RvmSatH2(-x*x+RvmH2(1.0,1.0));return x*x;}
//==============================================================
 RvmH3 RvmH(
//--------------------------------------------------------------
 // SV_POSITION, fragCoord.xy, etc
 RvmF2 ipos,
//--------------------------------------------------------------
 // inputSize / outputSize (in pixels)
 RvmF2 inputSizeDivOutputSize,     
//--------------------------------------------------------------
 // 0.5 * inputSize (in pixels)
 RvmF2 halfInputSize,
//--------------------------------------------------------------
 // 1.0 / inputSize (in pixels)
 RvmF2 rcpInputSize,
//--------------------------------------------------------------
 // 2.0 / outputSize (in pixels)
 RvmF2 twoDivOutputSize,   
//--------------------------------------------------------------
 // inputSize.y
 RvmF1 inputHeight,
//--------------------------------------------------------------
 // Warp scanlines
 //  0.0 = no warp
 //  1.0/64.0 = light warping
 //  1.0/32.0 = more warping
 // Want x and y warping to be different (based on aspect)
 RvmF2 warp,
//--------------------------------------------------------------
 // Control horizontal blur
 //  0.50 := blurry
 //  0.75 := default
 //  1.00 := blocky
 RvmH1 blur,
 // Derived constant {0.5*blur,-0.5*blur,-1.5*blur,-2.5*blur}
 RvmH4 blur4){
//--------------------------------------------------------------
  #ifdef RVM_ZOOM
   ipos=floor(ipos*RvmF2(0.5));
  #endif
//--------------------------------------------------------------
  // Optional apply warp
  RvmF2 pos;
  #ifdef RVM_WARP
   // Convert to {-1 to 1} range
   pos=ipos*twoDivOutputSize-RvmF2_(1.0);
   // Distort pushes image outside {-1 to 1} range
   pos*=RvmF2_(1.0)+pos.yx*pos.yx*warp;
   // Vignette to kill off-image content
   RvmF2 vin2=RvmSatF2(pos*pos);  
   // 1-((1-x)*(1-y)) -> (1-x)*y+x
   RvmF1 vin=(RvmF1(1.0)-vin2.x)*vin2.y+vin2.x;
   vin=RvmSatF1((-vin)*inputHeight+inputHeight);   
   // Leave in {0 to inputSize}
   pos=pos*halfInputSize+halfInputSize;     
  #else
   pos=ipos*inputSizeDivOutputSize;
  #endif
//--------------------------------------------------------------
  // Get to center for first gather 4
  //  W Z W Z
  //  X Y X Y
  #if RVM_MODE==0
   RvmF2 g=floor(pos+RvmF2(-1.5,-0.5))+RvmF2_(1.0);
   RvmF2 gp=g*rcpInputSize;
   g.y-=RvmF1(0.5);
  #endif
//--------------------------------------------------------------
  // Get to center for first gather 4
  //  W Z
  //  X Y
  //  W Z
  //  X Y
  #if RVM_MODE!=0
   RvmF2 g=floor(pos+RvmF2(-0.5,-1.5))+RvmF2_(1.0);
   RvmF2 gp=g*rcpInputSize;
   g.x-=RvmF1(0.5);
  #endif
//--------------------------------------------------------------
  // Using gather4 to keep in SoA form for packed 16-bit
  // Both 32-bit and 16-bit paths use same logic
  // Gather 4 ordering
  //  W Z
  //  X Y
  // 4x2 sampled footprint
  //  _S_ _T_
  //  W Z W Z
  //  X Y X Y
  #if RVM_MODE==0
   RvmH4 colRS=RvmR4H(gp);
   RvmH4 colGS=RvmG4H(gp);
   RvmH4 colBS=RvmB4H(gp);
   gp.x+=RvmF1(2.0*rcpInputSize.x);
   RvmH4 colRT=RvmR4H(gp);
   RvmH4 colGT=RvmG4H(gp);
   RvmH4 colBT=RvmB4H(gp);
  #endif
//--------------------------------------------------------------
  // 2x4 sampled footprint
  //  W Z |s
  //  X Y |s
  //  W Z :t
  //  X Y :t
  #if RVM_MODE!=0
   RvmH4 colRS=RvmR4H(gp);
   RvmH4 colGS=RvmG4H(gp);
   RvmH4 colBS=RvmB4H(gp);
   gp.y+=RvmF1(2.0*rcpInputSize.y);
   RvmH4 colRT=RvmR4H(gp);
   RvmH4 colGT=RvmG4H(gp);
   RvmH4 colBT=RvmB4H(gp);
  #endif
//--------------------------------------------------------------
  // Debug view without effect
  #ifdef RVM_SPLIT
   if(ipos.x<RvmF1(RVM_SPLIT)){
    return RvmH3(colRS.z,colGS.z,colBS.z);}
  #endif
//--------------------------------------------------------------
  // Horizontal kernel is simple gaussian filter approximation
  #if RVM_MODE==0
   RvmH1 offB=RvmH1(pos.x-g.x);
   RvmH2 offS=RvmH2(offB,offB)*RvmH2_(blur)+blur4.xy;
   RvmH2 offT=RvmH2(offB,offB)*RvmH2_(blur)+blur4.zw;
   RvmH2 horS=RvmPolyH2(offS);
   RvmH2 horT=RvmPolyH2(offT);
  #endif
//--------------------------------------------------------------
  // Vertical
  #if RVM_MODE!=0
   RvmH1 offB=RvmH1(pos.y-g.y);
   RvmH2 offS=RvmH2(offB,offB)*RvmH2_(blur)+blur4.xy;
   RvmH2 offT=RvmH2(offB,offB)*RvmH2_(blur)+blur4.zw;
   RvmH2 horS=RvmPolyH2(offS);
   RvmH2 horT=RvmPolyH2(offT);
  #endif
//--------------------------------------------------------------
  // Get kernel totals and then rcp
  RvmH2 hor0=horS+horT;
  RvmH1 horD=RvmRcpH1(hor0.x+hor0.y);
//--------------------------------------------------------------
  // Get rid of off-screen pixels on edge
  #ifdef RVM_WARP
   horD*=RvmH1(vin);
  #endif
//--------------------------------------------------------------
  // Apply horizontal filter, up and down sums
  #if RVM_MODE==0
   RvmH2 colRU2=colRS.wz*horS+colRT.wz*horT;
   RvmH2 colGU2=colGS.wz*horS+colGT.wz*horT;
   RvmH2 colBU2=colBS.wz*horS+colBT.wz*horT;
   RvmH2 colRD2=colRS.xy*horS+colRT.xy*horT;
   RvmH2 colGD2=colGS.xy*horS+colGT.xy*horT;
   RvmH2 colBD2=colBS.xy*horS+colBT.xy*horT;
//--------------------------------------------------------------
   // Pair total so that {x:=up, y:=down}
   // Expensive transpose from pairs of taps, to pairs of lines
   RvmH2 colRL=RvmH2(colRU2.x+colRU2.y,colRD2.x+colRD2.y);
   RvmH2 colGL=RvmH2(colGU2.x+colGU2.y,colGD2.x+colGD2.y);
   RvmH2 colBL=RvmH2(colBU2.x+colBU2.y,colBD2.x+colBD2.y);
  #endif
//--------------------------------------------------------------
  // Apply vertical filter
  #if RVM_MODE!=0
   RvmH2 colRL=colRS.wz*horS.xx+colRS.xy*horS.yy+
               colRT.wz*horT.xx+colRT.xy*horT.yy;  
   RvmH2 colGL=colGS.wz*horS.xx+colGS.xy*horS.yy+
               colGT.wz*horT.xx+colGT.xy*horT.yy;  
   RvmH2 colBL=colBS.wz*horS.xx+colBS.xy*horS.yy+
               colBT.wz*horT.xx+colBT.xy*horT.yy;  
  #endif
//--------------------------------------------------------------
  // Normalize by kernel total
  colRL*=RvmH2_(horD);
  colGL*=RvmH2_(horD);
  colBL*=RvmH2_(horD);
//--------------------------------------------------------------
  #if RVM_MODE==0
   // Get channel maximums and shape
   RvmH2 colML=RvmMax3H2(colRL,colGL,colBL);
   // TODO: Approximation...
   colML=sqrt(colML);
//--------------------------------------------------------------
   // Convert shaped channel maximums into scan width
   RvmH2 scnL=colML*RvmH2_(RVM_SCAN_SIZ)+RvmH2_(RVM_SCAN_MIN);
   RvmH1 offY=RvmH1(pos.y-g.y);
   scnL.x=( offY)*scnL.x;  
   scnL.y=(-offY)*scnL.y+scnL.y;  
   scnL=min(RvmH2_(0.5),scnL);
   scnL=RvmNCosH2(scnL);
   scnL=scnL*RvmH2_(0.5)+RvmH2_(0.5);
//--------------------------------------------------------------
   // Normalize for reduction in scan width
   RvmH2 nrmL=RvmH2_(1.0)-colML;
   nrmL=nrmL*RvmH2_(RVM_SCAN_MIN/RVM_SCAN_MAX-1.0)+RvmH2_(1.0);
   scnL*=nrmL;
  #endif
//--------------------------------------------------------------
  #if RVM_MODE!=0
   RvmH1 offX=RvmH1(pos.x-g.x);
   RvmH2 scnL=RvmH2(RvmH1(1.0)-offX,offX);
  #endif
//--------------------------------------------------------------
  // Apply scan
  colRL*=scnL; 
  colGL*=scnL;   
  colBL*=scnL;
//--------------------------------------------------------------
  // Merge contribution from both nearest lines
  RvmH3 col;
  col.r=colRL.x+colRL.y;
  col.g=colGL.x+colGL.y;
  col.b=colBL.x+colBL.y;
//--------------------------------------------------------------
  // Grille
  #if RVM_MODE==1
   RvmH1 lim=RvmH1(1.0/((1.0/3.0)+(2.0/3.0)*RVM_DARK));
   RvmH3 colD=col*col;
   colD*=RVM_DARK;
   RvmH3 amp=RvmRcpH3(
    RvmH3_(lim*1.0/3.0)+RvmH3_(lim*2.0/3.0)*col);
   ipos.x=RvmFractF1(ipos.x*RvmF1(1.0/3.0));
   col*=amp;colD*=amp;
   if(     ipos.x<RvmF1(1.0/3.0)){colD.r=col.r;}
   else if(ipos.x<RvmF1(2.0/3.0)){colD.g=col.g;}
   else                          {colD.b=col.b;}
   return colD;
  #endif
//--------------------------------------------------------------
  // Slot mask
  #if RVM_MODE==2
   RvmH1 lim=RvmH1(1.0/((3.0/12.0)+(9.0/12.0)*RVM_DARK));
   if(RvmFractF1(ipos.x*RvmF1(1.0/6.0))>RvmF1(0.5))
    ipos.y+=RvmF1(2.0);
   ipos.y=RvmFractF1(ipos.y*RvmF1(1.0/4.0));
   RvmH3 colD=col*col;
   colD*=RVM_DARK;
   RvmH3 amp=RvmRcpH3(
    RvmH3_(lim*3.0/12.0)+RvmH3_(lim*9.0/12.0)*col);
   ipos.x=RvmFractF1(ipos.x*RvmF1(1.0/3.0));
   col*=amp;colD*=amp;
   if(ipos.y>RvmF1(1.0/4.0)){
    if(     ipos.x<RvmF1(1.0/3.0)){colD.r=col.r;}
    else if(ipos.x<RvmF1(2.0/3.0)){colD.g=col.g;}
    else                          {colD.b=col.b;}}
   return colD;
  #endif
//--------------------------------------------------------------
  return col;}
#endif


//________________________END_HEADER____________________________
//________________________END_HEADER____________________________
//________________________END_HEADER____________________________
//________________________END_HEADER____________________________
//________________________END_HEADER____________________________
//________________________END_HEADER____________________________
//________________________END_HEADER____________________________
//________________________END_HEADER____________________________


//_____________________________/\_______________________________
//==============================================================
//                    USE HEADER IN SHADER
//--------------------------------------------------------------
// Example of integrating
// What to do after including header
//==============================================================
// Convert from linear to sRGB
// Since shader toy output is not linear
float ToSrgb1(float c){
 return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}
//--------------------------------------------------------------
vec3 ToSrgb(vec3 c){return vec3(
 ToSrgb1(c.r),ToSrgb1(c.g),ToSrgb1(c.b));}
//--------------------------------------------------------------
void mainImage(out vec4 fragColor,in vec2 fragCoord){
 vec2 res=iResolution.xy/vec2(INPUT_DOT,INPUT_DOT);
 fragColor.rgb=RvmF(
  fragCoord.xy,       // ipos
  res/iResolution.xy, // inputSizeDivOutputSize
  res*vec2(0.5,0.5),  // halfInputSize
  1.0/res,            // rcpInputSize
  2.0/iResolution.xy, // twoDivOutputSize
  res.y,
  #if RVM_MODE==0
   vec2(1.0/256.0,1.0/24.0),
  #endif
  #if RVM_MODE==1
   vec2(1.0/4096.0,1.0/24.0),
  #endif
  #if RVM_MODE==2
   vec2(1.0/48.0,1.0/24.0),
  #endif
  INPUT_BLUR,
  RvmF4(0.5*INPUT_BLUR,-0.5*INPUT_BLUR,-1.5*INPUT_BLUR,-2.5*INPUT_BLUR));
 // Shadertoy outputs non-linear color   
 fragColor.rgb=ToSrgb(fragColor.rgb);}